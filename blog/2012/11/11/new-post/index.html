<p>z</p>

<p>I just got done presenting <a href="">Writing Testable JavaScript</a> at <a href="">Full Frontal 2012</a>, a fantastic conference in beautiful Brighton in the UK, organized and hosted by the amazing Remy and Julie Sharp. As it turns out, the last <a href="">go-to post about writing testable JavaScript</a> was written a few years ago; I wanted to try to write down some thoughts based on my presentation in hopes they might help folks out now that there are some great tools that make testing JavaScript a lot easier than it was back then.</p>

<p>A couple of months ago, I asked people on Twitter a couple of months ago what was making it hard to get started with JavaScript. Several people wrote to say they were stumped about how to write JavaScript that was testable in the first place &#8211; they knew that certain patterns made JavaScript hard to test, but they didn&#8217;t seem to know how best to avoid those patterns. To that end, I want to spend the rest of this post talking about how to write testable JavaScript, and specifically about how to incorporate <a href="">unit tests</a> into your development process.</p>

<h2>Why Test?</h2>

<p>Unlike in some other languages, testing hasn&#8217;t been a strong part of JavaScript culture. However, it&#8217;s becoming more relevant as we take on more complex tasks with JavaScript, and as we discover that our code is sometimes living a longer life than we ever thought possible. The move toward testing is an acknowledgement of a few facts of development life:</p>

<ul>
<li><strong>You will design your code</strong>. Before you write a line of code, you spend 10 seconds, 10 minutes, or maybe even a couple of hours thinking about how you&#8217;ll approach a problem. Unit testing makes that design process a more methodical one.</li>
<li><strong>You will test your code</strong>. Whether your method of testing is refreshing your browser, sending code to QA, writing tests, or waiting for users to report bugs, your code will be tested one way or another. Automated testing allows that testing to happen earlier, and with minimal effort.</li>
<li><strong>You will need to touch your code again</strong>. Remember that feature your boss said was solidly specified and would never need to change? Remember that code you just needed to get out the door and you&#8217;d revisit it as soon as you had time? You know how that ended up. Testing lets you refactor with greater confidence.</li>
<li><strong>Other people will use your code</strong>. Maybe it&#8217;s a new team member, or your client, or a third party &#8211; regardless, tests help others understand what they can expect of your code, and give them ample warning when they break it.</li>
<li><strong>There will be bugs</strong>. No matter how much testing you do, there are almost guaranteed to be bugs. Bugs don&#8217;t mean testing was a failure or a waste of effort &#8211; they&#8217;re just an opportunity to write another test.</li>
</ul>


<h2>An Example App</h2>

<p>For the rest of this post, we&#8217;ll look at a simple example app:</p>

<p><img src="" alt="" /></p>

<p>A user searches for a term, and search results appear; a user can then click on the &#8220;Like&#8221; button next to a search result to add it to the list of liked results on the right.</p>

<p>A traditional jQuery-style approach to this application might look something like this:</p>

<p><a href="">gist</a></p>

<h2>Integration Tests</h2>

<p>When it comes to verifying that this code &#8220;works,&#8221; the best we can do is test that the eventual outcome is what we expect it to be &#8211; that is, when a user searches for something, do they eventually see the right results? These sorts of tests are called <em>integration tests</em> &#8211; they test whether pieces of a system work together.</p>

<p>We can use Selenium to write these tests, and there are Selenium packages for Ruby, Java, Python, and even JavaScript. The JavaScript flavor is callback-heavy without much benefit, but here&#8217;s what a Selenium test might look like in Ruby, using <a href="">Capybara</a>:</p>

<p><a href="">gist</a></p>

<p>The code simply states a series of user interactions, and verifies that the page looks as it should at the end of those interactions. Here&#8217;s a video of the tests running:</p>

<p><a href="">video</a></p>

<p>Integration tests are great for verifying that pieces of your app are working together, and if you don&#8217;t have any tests at all, they&#8217;re the first kind of tests that you should write before you start tearing your code apart. But while they do somewhat assist with refactoring, they don&#8217;t help you design your code in the first place, and they don&#8217;t really tell other developers what they can expect of your code. For that, we need unit tests.</p>

<h2>Unit Tests</h2>

<p>Unit tests test <em>units of functionality</em>: given input X, did I get output Y? If we look again at the <a href="">traditional implementation</a>, it&#8217;s incredibly difficult to unit test: we can&#8217;t even get access to individual units of functionality. Does the query get sent correctly? Are the results populated correctly with the data returned by the server? Are form submissions prevented when a search is pending?</p>

<p>There are a few characteristics that make this code difficult to test:</p>

<ul>
<li><strong>Anonymous functions</strong> Functions that don&#8217;t have names can&#8217;t be called, so we can&#8217;t test that their output is correct for a given input.</li>
<li><strong>Complex functions</strong> Functions that do lots of things can have side effects that are difficult to test.</li>
<li><strong>Lack of configurability</strong> The code is filled with hard-coded selectors, which means we have to replicate the entire DOM it expects in order to test any of it.</li>
<li><strong>Hidden or shared state</strong> As an example: the pending state of the search form is closed inside the form&#8217;s submit handler, where we can&#8217;t test that it&#8217;s accurately set or released.</li>
<li><strong>Tight coupling</strong> The event handler on a search result&#8217;s &#8220;Like&#8221; button updates the list of liked results directly, which means the results list needs to &#8220;know&#8221; about the liked results. Likewise, the search form needs to know about the results list, and its submit handler communicates directly with the server.</li>
</ul>


<h3>Rethinking Our Code</h3>

<p>My colleague <a href="">Adam Sontag</a> calls this &#8220;choose-your-own-adventure&#8221; code: on any given line, you don&#8217;t know what might happen next. If we want testable code, our first step is to embrace a less-tangled approach. Most client-side functionality can be broken down into four areas of responsibility:</p>

<ul>
<li>Presentation/interaction</li>
<li>Data/server communication</li>
<li>Application state</li>
<li>The glue that connects the first three</li>
</ul>


<p>If we look at our traditional code, these four areas of responsibility are intermingled:</p>

<p><img src="" alt="" /></p>

<p>A more reasonable approach to our application might be broken down into a few pieces:</p>

<ul>
<li>Presentation/interaction: The search form, the search results, and the likes</li>
<li>Data/server communication: Fetching the results from the server based on a provided search term</li>
<li>Application state: The current search term and other client-side state information</li>
<li>Glue: Setting up the above pieces, and brokering communication between them</li>
</ul>


<p>Once we&#8217;ve sketched out the general layout of our application, based on the four areas of responsibility, there are a few guiding principles we can follow to make our implementation more testable:</p>

<ul>
<li>Use constructors to create instances</li>
<li>Support configurability</li>
<li>Keep methods simple</li>
<li>Don&#8217;t intermingle responsibilities</li>
</ul>


<p>We&#8217;ll see how these four principles play out below, but there&#8217;s one last principle to mention that <em>guarantees</em> our code will be testable, and tested: test first.</p>

<h3>Test First</h3>

<p>I&#8217;m the first to admit that I don&#8217;t always test, and I don&#8217;t always test first. Some people swear by it, and it certainly has many advantages. When I do write tests first, it has a dramatic effect on how I think about writing my code. I&#8217;m forced to think about the API that different modules will need to expose, and I&#8217;m forced to think about what a given module needs to <em>do</em>. Then, I write those requirements out in plain English, and then I write code that will prove that the requirements are met.</p>

<p>One of the best feelings in the world, as a developer, is writing your tests first, writing implementations that make those tests pass, and then firing up the application in the browser and seeing it just work. Even if you don&#8217;t test first as a rule, I strongly encourage trying it for a little while, at least to see how it affects your process and when it might be a useful approach for you.</p>

<h2>Writing Our Tests</h2>
